#!/bin/bash

set -efu

declare -r L='{' R='}' D='$' B='\' S=' ' Q="'" QQ='"'

usage() {
  cat <<EOF
USAGE: $0 [-v] <program> [args ...]

    -v  debug mode
EOF
  exit
}
error() {
  local msg
  case "$1" in
    eof) msg='no newline at end of file';;
    match) msg="missing subst after match: $2";;
    option) msg="unknown option: $2";;
    *) usage;;
  esac
  echo "ERROR: $msg" >&2
  exit 1
}
escape() {
  local opts=()
  opts+=(-e s"/$L/{L}/"g)
  opts+=(-e s"/$R/{R}/"g)
  opts+=(-e s"/{L${L}R}/{L}/"g)
  opts+=(-e s"/$B$D/{D}/"g)
  opts+=(-e s"/$B$B/{B}/"g)
  opts+=(-e s"/$S/{S}/"g)
  opts+=(-e s"/$Q/{Q}/"g)
  opts+=(-e s"/$QQ/{QQ}/"g)
  sed "${opts[@]}"
}
unescape() {
  local tmp=$(sed -e s"/\({[^{}]*}\)/$B$D\1/"g)
  eval echo "$tmp"
}
escape-match() {
  local opts=() d='\$' b='\\'
  opts+=(-e s"/$d/$b$d/"g)
  opts+=(-e s"/$b$/$b$b/"g)
  sed "${opts[@]}"
}
escape-subst() {
  local opts=() d='\$' b='\\' s=' ' q="'" qq='"'
  opts+=(-e s"/$d/$b$d/"g)
  opts+=(-e s"/$b$d\([0-9]\)/$d{arg\1}/"g)
  opts+=(-e s"/$s/$d{s}/"g)
  opts+=(-e s"/$q/$d{q}/"g)
  opts+=(-e s"/$qq/$d{qq}/"g)
  sed "${opts[@]}"
}
parse-rule() {
  local i line msg prev= n=$'\n'
  COUNT=0
  for ((i=1; ; i++)); do
    if ! read -r line; then
      test "$line" && error eof
      test "$prev" && error match "$msg"
      break
    fi
    if ! test "$prev"; then
      if test "$line"; then
        prev=$line
        msg="${n}line:$i: $line"
      fi
    else
      test "$line" || error match "$msg"
      eval MATCH_$COUNT='$prev'
      eval SUBST_$COUNT='$line'
      declare -r MATCH_$COUNT SUBST_$COUNT
      ((COUNT+=1))
      prev=
    fi
  done
  declare -r COUNT
}
init() {
  (($#)) || error usage
  case "$1" in
    -v) DEBUG=on; shift;;
    -*) error option "$1";;
  esac
  parse-rule <"$1"
  shift
  ARGS=('$' "$@")
}
load-pattern() {
  local match=MATCH_$1
  local subst=SUBST_$1
  local ifs=$IFS
  IFS=$'\t'
  MATCH=(${!match})
  SUBST=(${!subst})
  IFS=$ifs
}
pattern-match() {
  local match
  set -- "${ARGS[@]}"
  for match in "${MATCH[@]}"; do
    (($#)) || return
    match=$(escape-match <<<"$match")
    [[ "$1" =~ ^$match$ ]] || return
    shift
  done
}
scan-match() {
  local i
  for ((i=0; i<COUNT; i++)); do
    load-pattern "$i"
    pattern-match && return
  done
  return 1
}
rewrite() {
  local i count=${#MATCH[@]} subst s=' ' q="'" qq='"'
  for ((i=0; i<count; i++)); do
    local arg$i="${ARGS[$i]}"
  done
  UPDATE=()
  for subst in "${SUBST[@]}"; do
    subst=$(escape-subst <<<"$subst")
    eval subst=$subst
    UPDATE+=("$subst")
  done
  UPDATE+=("${ARGS[@]:count}")
}
debug() {
  local prefix ifs=$IFS
  test -z "${DEBUG-}" && return
  IFS=$'\t'
  echo " -> ${ARGS[*]}"
  IFS=$ifs
}
run() {
  while scan-match; do
    rewrite
    debug
    ARGS=("${UPDATE[@]}")
  done
  echo "${ARGS[@]}"
}

init "$@"
run
