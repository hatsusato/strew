#!/bin/bash

set -efu

declare -r LC='{' RC='}' LP='(' RP=')' D='$' B='\' S=' ' Q="'" QQ='"'
declare -r B2=$B BB=$B$B BD=$B$D

# error handling
usage() {
  cat <<EOF >&2
USAGE: $0 [-v] <program> [args ...]

    -v  debug mode
EOF
  exit 1
}
error-eof() {
  cat <<EOF >&2
ERROR: no newline at end of file
EOF
  exit 1
}
error-halt() {
  local ifs=$IFS
  IFS=$'\t'
  local msg=${ARGS[*]}
  IFS=$ifs
  cat <<EOF >&2
ERROR: no transition rule:
$msg
EOF
  exit 1
}
error-missing() {
  cat <<EOF >&2
ERROR: missing subst after match:
$msg
EOF
  exit 1
}
error-option() {
  cat <<EOF >&2
ERROR: unknown option: $msg
EOF
  usage
}
error-file() {
  cat <<EOF
ERROR: not found: $msg
EOF
  exit 1
}

# escape
escape() {
  local opts=()
  opts+=(-e s"/$LC/{LC}/"g)
  opts+=(-e s"/$RC/{RC}/"g)
  opts+=(-e s"/{LC${LC}RC}/{LC}/"g)
  opts+=(-e s"/$LP/{LP}/"g)
  opts+=(-e s"/$RP/{RP}/"g)
  opts+=(-e s"/$B$D/{D}/"g)
  opts+=(-e s"/$B$B/{B}/"g)
  opts+=(-e s"/$S/{S}/"g)
  opts+=(-e s"/$Q/{Q}/"g)
  opts+=(-e s"/$QQ/{QQ}/"g)
  sed "${opts[@]}"
}
unescape() {
  local tmp=$(sed -e s"/\({[^{}]*}\)/$BD\1/"g)
  eval echo "$tmp"
}

# initialization
read-line() {
  local ifs=$IFS
  local -i err=0
  IFS=
  read -r line || err=$?
  IFS=$ifs
  return $err
}
parse-rules() {
  local line prev= msg
  declare -ig COUNT=0
  local -i i
  for ((i=1; ; i++)); do
    if ! read-line; then
      test "$line" && error-eof
      test "$prev" && error-missing
      break
    elif test "$prev"; then
      test "$line" || error-missing
      local -n match=MATCH_$COUNT subst=SUBST_$COUNT
      match=$prev
      subst=$line
      declare -r MATCH_$COUNT SUBST_$COUNT
      ((COUNT+=1))
      prev=
    elif test "$line"; then
      prev=$line
      msg="line:$i: $line"
    fi
  done
  declare -r COUNT
}
init() {
  local msg
  declare -g DEBUG ARGS
  (($#)) || usage
  while [[ "${1-}" == -* ]]; do
    msg=$1
    shift
    case "$msg" in
      -h) usage;;
      -v) DEBUG=on;;
      -*) error-option;;
    esac
  done
  (($#)) || usage
  msg=$1
  test -f "$1" || error-file
  parse-rules <"$1"
  shift
  ARGS=('$' "$@")
}

# matching
split-tabs() {
  local str=${!1} arr=() t=$'\t'
  while test "$str"; do
    if [[ "$str" == *$t* ]]; then
      arr+=("${str%%$t*}")
      str=${str#*$t}
    else
      arr+=("$str")
      str=
    fi
  done
  eval "$2=(${arr[@]@Q})"
}
escape-match() {
  local opts=()
  opts+=(-e s'/{B}{B}/{BB}/'g)
  opts+=(-e s"/{D}/{BD}/"g)
  opts+=(-e s"/{B}$/{BB}/"g)
  escape | sed "${opts[@]}" | unescape
}
pattern-match() {
  local match
  set -- "${ARGS[@]}"
  for match in "${MATCH[@]}"; do
    (($#)) || return
    match=$(escape-match <<<"$match")
    [[ "$1" =~ ^$match$ ]] || return
    shift
  done
}
scan-match() {
  local i
  for ((i=0; i<COUNT; i++)); do
    split-tabs MATCH_$i MATCH
    split-tabs SUBST_$i SUBST
    pattern-match && return
  done
  return 1
}

# rewriting
escape-subst() {
  local -a opts
  opts+=(-e s'/{B}{B}/{B2}/'g)
  opts+=(-e s"/{B}{D}/{BD}/"g)
  local -i i j
  for ((i=0; i<count; i++)); do
    local -n rematch=rematch_$i
    for ((j=1; j<${#rematch[@]}; j++)); do
      opts+=(-e s"/{D}$i$((j-1))/{rematch_$i[$j]}/"g)
    done
    opts+=(-e s"/{D}$i/{rematch_$i[0]}/"g)
  done
  escape | sed "${opts[@]}" | unescape
}
rewrite() {
  local match subst
  local -i count=0
  for match in "${MATCH[@]}"; do
    match=$(escape-match <<<"$match")
    [[ "${ARGS[$count]}" =~ ^$match$ ]] || :
    local -a rematch_$count
    local -n rematch=rematch_$count
    rematch=("${BASH_REMATCH[@]}")
    ((count+=1))
  done
  UPDATE=()
  for subst in "${SUBST[@]}"; do
    subst=$(escape-subst <<<"$subst")
    UPDATE+=("$subst")
  done
  UPDATE+=("${ARGS[@]:count}")
}

# entry point
debug() {
  local ifs=$IFS
  test -z "${DEBUG-}" && return
  IFS=$'\t'
  echo " -> ${ARGS[*]}"
  IFS=$ifs
}
run() {
  while test "${ARGS[0]}"; do
    scan-match || error-halt
    rewrite
    debug
    ARGS=("${UPDATE[@]}")
  done
  echo "${ARGS[@]:1}"
}

init "$@"
run
