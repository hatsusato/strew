#!/bin/bash

set -efu

usage() {
  cat <<EOF
USAGE: $0 [-v] <program> [args ...]

    -v  debug mode
EOF
  exit
}
error() {
  local msg
  case "$1" in
    eof) msg='no newline at end of file';;
    match) msg="missing subst after match: $2";;
    option) msg="unknown option: $2";;
    *) usage;;
  esac
  echo "ERROR: $msg" >&2
  exit 1
}
init-rule() {
  local i line msg prev= n=$'\n'
  COUNT=0
  for ((i=1; ; i++)); do
    if ! read -r line; then
      test "$line" && error eof
      test "$prev" && error match "$msg"
      break
    fi
    if ! test "$prev"; then
      if test "$line"; then
        prev=$line
        msg="${n}line:$i: $line"
      fi
    else
      test "$line" || error match "$msg"
      eval MATCH_$COUNT='$prev'
      eval SUBST_$COUNT='$line'
      ((COUNT+=1))
      prev=
    fi
  done
}
init() {
  (($#)) || error usage
  case "$1" in
    -v) DEBUG=on; shift;;
    -*) error option "$1";;
  esac
  init-rule <"$1"
  shift
  ARGS=('$$' "$@")
  INDEX=0
}
load-rule() {
  local match=MATCH_$INDEX
  local subst=SUBST_$INDEX
  local ifs=$IFS
  IFS=$'\t'
  MATCH=(${!match})
  SUBST=(${!subst})
  IFS=$ifs
}
pattern-match() {
  local i
  load-rule
  for ((i=0; i<${#MATCH[@]}; i++)); do
    ((i < ${#ARGS[@]})) || return
    [[ "${ARGS[$i]}" == ${MATCH[$i]} ]] || return
  done
}
scan-match() {
  local i
  for ((INDEX=0; INDEX<COUNT; INDEX++)); do
    pattern-match && return
  done
  return 1
}
rewrite() {
  local s a b i=0
  UPDATE=()
  for s in "${SUBST[@]}"; do
    for ((i=0; i<${#ARGS[@]}; i++)); do
      a=${ARGS[$i]}
      b='$'$i
      s=${s//$b/$a}
    done
    UPDATE+=("$s")
  done
}
debug() {
  test -z "${DEBUG-}" && return
  local a=() r=() ifs=$IFS
  a=(args:$INDEX: "${ARGS[@]}" '$' "${UPDATE[@]}")
  r=(rule:$INDEX: "${MATCH[@]}" '$' "${SUBST[@]}")
  IFS=$'\t'
  echo "${r[*]}" >&2
  echo "${a[*]}" >&2
  IFS=$ifs
}
run() {
  local a=()
  while scan-match; do
    rewrite
    debug
    ARGS=("${UPDATE[@]}")
  done
  echo "${ARGS[@]}"
}

init "$@"
run
