#!/bin/bash

set -efu

declare -r LC='{' RC='}' LP='(' RP=')' D='$' B='\' S=' ' Q="'" QQ='"'
declare -r B2=$B BB=$B$B BD=$B$D
declare -r REMATCH_PREFIX=REMATCH_

# utility
defined() {
  local -n var_=$1
  test "${var_+set}"
}
concat() {
  local -n var_=$1
  local ifs=$IFS
  IFS=$DELIM
  echo "${var_[*]}"
  IFS=$ifs
}
split() {
  local src=$1 t=$DELIM
  local -n dst_=$2
  dst_=()
  while test "$src"; do
    if [[ "$src" == *$t* ]]; then
      dst_+=("${src%%$t*}")
      src=${src#*$t}
    else
      dst_+=("$src")
      src=
    fi
  done
}

# error handling
usage() {
  cat <<EOF >&2
USAGE: $0 [-v] [-d DELIM] PROGRAM [args ...]

    -v  debug mode
    -d  use DELIM instead of TAB for delimiter
EOF
  exit 1
}
error() {
  local -i err=$?
  local cmd=$1 msg n=$'\n'
  shift
  ((err)) || err=1
  msg='ERROR: '
  case $cmd in
    eof) msg+='no newline at end of file';;
    eval) msg+='outbound index in this subst';;
    extra) msg+='missing extra option';;
    file) msg+='file not found';;
    halt) msg+='no transition rule';;
    missing) msg+='missing subst after match';;
    option) msg+='unknown option';;
  esac
  msg+=:
  case $cmd in
    eval) msg+="$n$(concat SUBST_$INDEX)";;
    halt) msg+="$n$(concat ARGS)";;
    missing) msg+="$n$@";;
    extra|file|option) msg+=" $@";;
  esac
  echo "$msg" >&2
  case $cmd in
    option) usage;;
    *) exit $err;;
  esac
}

# escape
escape-preprocess() {
  local -n opts_=$1
  opts_+=(-e s"/$LC/{LC}/"g)
  opts_+=(-e s"/$RC/{RC}/"g)
  opts_+=(-e s"/{LC${LC}RC}/{LC}/"g)
  opts_+=(-e s"/$LP/{LP}/"g)
  opts_+=(-e s"/$RP/{RP}/"g)
  opts_+=(-e s"/$BD/{D}/"g)
  opts_+=(-e s"/$BB/{B}/"g)
  opts_+=(-e s"/$S/{S}/"g)
  opts_+=(-e s"/$Q/{Q}/"g)
  opts_+=(-e s"/$QQ/{QQ}/"g)
}
escape-prepare-match() {
  local -n opts_=$1
  if ! defined ESCAPE_MATCH_OPTS; then
    declare -ag ESCAPE_MATCH_OPTS
    escape-preprocess ESCAPE_MATCH_OPTS
    ESCAPE_MATCH_OPTS+=(-e s'/{B}{B}/{BB}/'g)
    ESCAPE_MATCH_OPTS+=(-e s"/{D}/{BD}/"g)
    ESCAPE_MATCH_OPTS+=(-e s"/{B}$D/{BB}/"g)
    declare -gr ESCAPE_MATCH_OPTS
  fi
  opts_=("${ESCAPE_MATCH_OPTS[@]}")
}
escape-prepare-subst() {
  local -n opts_=$1
  if ! defined ESCAPE_SUBST_OPTS; then
    local -r pre=$REMATCH_PREFIX
    declare -ag ESCAPE_SUBST_OPTS
    escape-preprocess ESCAPE_SUBST_OPTS
    ESCAPE_SUBST_OPTS+=(-e s'/{B}{B}/{B2}/'g)
    ESCAPE_SUBST_OPTS+=(-e s"/{B}{D}/{BD}/"g)
    ESCAPE_SUBST_OPTS+=(-e s"/{D}\([0-9]\)\([0-9]\)\?/{D}{LC}\1\2{RC}/"g)
    ESCAPE_SUBST_OPTS+=(-e s"/{D}{LC}\([0-9]\){RC}/{D}{LC}\10{RC}/"g)
    ESCAPE_SUBST_OPTS+=(-e s"/{D}{LC}\([0-9]\)\([0-9]\){RC}/{$pre\1[\2]}/"g)
    declare -gr ESCAPE_SUBST_OPTS
  fi
  opts_=("${ESCAPE_SUBST_OPTS[@]}")
}
escape() {
  local -n opts_=$1
  local tmp
  tmp=$(sed "${opts_[@]}" -e s"/\({[^{}]*}\)/$BD\1/"g)
  (eval echo "$tmp") || error eval
}

# initialization
read-line() {
  local ifs=$IFS
  local -i err=0
  IFS=
  read -r line || err=$?
  IFS=$ifs
  return $err
}
parse-rules() {
  declare -ig COUNT=0
  local line prev= msg
  local -i i
  for ((i=1; ; i++)); do
    if ! read-line; then
      test "$line" && error eof
      test "$prev" && error missing "$msg"
      break
    elif test "$prev"; then
      test "$line" || error missing "$msg"
      declare -ag MATCH_$COUNT SUBST_$COUNT
      split "$prev" MATCH_$COUNT
      split "$line" SUBST_$COUNT
      declare -gr MATCH_$COUNT SUBST_$COUNT
      ((COUNT++)) || :
      prev=
    elif test "$line"; then
      prev=$line
      msg="line:$i: $line"
    fi
  done
  declare -gr COUNT
}
parse-option() {
  declare -g DEBUG DELIM='\t'
  local -i i=0 j=0
  while [[ "${1-}" == -* ]]; do
    j=1
    case "$1" in
      -d) ((1 < $#)) || error extra "$1";
          DELIM=$2; j=2;;
      -h) usage;;
      -v) DEBUG=on;;
      -*) error option "$1";;
    esac
    shift $j
    ((i+=j)) || :
  done
  DELIM=$(printf "$DELIM")
  (($#)) || usage
  return $i
}
init() {
  parse-option "$@" || shift $?
  test -f "$1" || error file "$1"
  parse-rules <"$1"
  shift
  declare -ag ARGS=('$' "$@")
}

# matching
rematch() {
  declare -ag $1
  local -n rematch_=$1
  shift
  rematch_=("${BASH_REMATCH[@]}")
}
pattern-match() {
  local -n match_=MATCH_$INDEX
  local -a opts
  local -i i
  local match rematch=${1-:}
  set -- "${ARGS[@]}"
  escape-prepare-match opts
  for ((i=0; i<${#match_[@]}; i++)); do
    (($#)) || return
    match=$(escape opts <<<"${match_[i]}")
    [[ "$1" =~ ^$match$ ]] || return
    shift
    $rematch $REMATCH_PREFIX$i
  done
  declare -ag REST=("$@")
}
scan-match() {
  declare -ig INDEX
  for ((INDEX=0; INDEX<COUNT; INDEX++)); do
    pattern-match && return
  done
  return 1
}

# rewriting
rewrite() {
  local -n subst_=SUBST_$INDEX
  local -a opts update
  local subst
  escape-prepare-subst opts
  pattern-match rematch
  for subst in "${subst_[@]}"; do
    subst=$(escape opts <<<"$subst")
    update+=("$subst")
  done
  ARGS=("${update[@]}" "${REST[@]}")
}

# entry point
debug() {
  if defined DEBUG; then
    echo " -> $(concat ARGS)"
  fi
}
run() {
  while test "${ARGS[0]}"; do
    debug
    scan-match || error halt
    rewrite
  done
  echo "${ARGS[@]:1}"
}

init "$@"
run
